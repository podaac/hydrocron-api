# This is the main build pipeline that verifies and publishes the software
name: Build
# Controls when the workflow will run
on:
  # Triggers the workflow on push events
  push:
    branches: [ develop, release/**, main, feature/**, issue/**, dependabot/** ]
    tags-ignore:
      - '*'
    paths-ignore:
      - 'pyproject.toml'

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

env:
  POETRY_VERSION: "1.3.1"
  PYTHON_VERSION: "3.10"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # First job in the workflow installs and verifies the software
  build:
    name: Build, Test, Verify, Publish
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    steps:
      - uses: getsentry/action-github-app-token@v2
        name: podaac cicd token
        id: podaac-cicd
        with:
          app_id: ${{ secrets.CICD_APP_ID }}
          private_key: ${{ secrets.CICD_APP_PRIVATE_KEY }}
      - uses: actions/checkout@v3
        with:
          repository: ${{ github.repository }}
          token: ${{ steps.podaac-cicd.outputs.token }}
      - uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Install Poetry
        uses: abatilo/actions-poetry@v2
        with:
          poetry-version: ${{ env.POETRY_VERSION }}
      - name: Get version
        id: get-version
        run: |
          echo "current_version=$(poetry version | awk '{print $2}')" >> $GITHUB_OUTPUT
          echo "pyproject_name=$(poetry version | awk '{print $1}')" >> $GITHUB_ENV
      - name: Bump pre-alpha version
        # If triggered by push to a feature branch
        if: |
          startsWith(github.ref, 'refs/heads/feature') ||
          startsWith(github.ref, 'refs/heads/issue')     ||
          startsWith(github.ref, 'refs/heads/dependabot')
        run: |
          new_ver="${{ steps.get-version.outputs.current_version }}+$(git rev-parse --short ${GITHUB_SHA})"
          poetry version $new_ver
          echo "software_version=$(poetry version | awk '{print $2}')" >> $GITHUB_ENV
      - name: Bump alpha version
        # If triggered by push to the develop branch
        if: ${{ github.ref == 'refs/heads/develop' }}
        run: |
          poetry version prerelease
          echo "software_version=$(poetry version | awk '{print $2}')" >> $GITHUB_ENV
          echo "venue=sit" >> $GITHUB_ENV
      - name: Bump rc version
        # If triggered by push to a release branch
        if: ${{ startsWith(github.ref, 'refs/heads/release/') }}
        env:
          # True if the version already has a 'rc' pre-release identifier
          BUMP_RC: ${{ contains(steps.get-version.outputs.current_version, 'rc') }}
        run: |
          if [ "$BUMP_RC" = true ]; then
            poetry version prerelease
          else
            poetry version ${GITHUB_REF#refs/heads/release/}-rc.1
          fi
          echo "software_version=$(poetry version | awk '{print $2}')" >> $GITHUB_ENV
          echo "venue=uat" >> $GITHUB_ENV
      - name: Release version
        # If triggered by push to the main branch
        if: ${{ startsWith(github.ref, 'refs/heads/main') }}
        env:
          CURRENT_VERSION: ${{ steps.get-version.outputs.current_version }}
        # Remove -rc.* from end of version string
        # The ${string%%substring} syntax below deletes the longest match of $substring from back of $string.
        run: |
          poetry version ${CURRENT_VERSION%%-rc.*}
          echo "software_version=$(poetry version | awk '{print $2}')" >> $GITHUB_ENV
          echo "venue=ops" >> $GITHUB_ENV
      - name: Install hydrocron
        run: poetry install
      - name: Lint
        run: |
          poetry run pylint hydrocronapi
          poetry run flake8 hydrocronapi
          pip3 install boto
          npm install
      - name: Run Snyk as a blocking step
        uses: snyk/actions/python-3.9@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          command: test
          args: >
            --org=${{ secrets.SNYK_ORG_ID }}
            --project-name=${{ github.repository }}
            --severity-threshold=high
            --fail-on=all
      - name: Run Snyk on Python
        uses: snyk/actions/python-3.9@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          command: monitor
          args: >
            --org=${{ secrets.SNYK_ORG_ID }}
            --project-name=${{ github.repository }}
      - name: Commit Version Bump
        # If building develop, a release branch, or main then we commit the version bump back to the repo
        if: |
          github.ref == 'refs/heads/develop' ||
          github.ref == 'refs/heads/main'    ||
          startsWith(github.ref, 'refs/heads/release')
        run: |
          git config user.name "${GITHUB_ACTOR}"
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git commit -am "/version ${{ env.software_version }}"
          git push
      - name: Push Tag
        if: |
          github.ref == 'refs/heads/develop' ||
          github.ref == 'refs/heads/main'    ||
          startsWith(github.ref, 'refs/heads/release')
        run: |
          git config user.name "${GITHUB_ACTOR}"
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git tag -a "${{ env.software_version }}" -m "Version ${{ env.software_version }}"
          git push origin "${{ env.software_version }}"
      - name: Build Python Artifact
        run: |
          poetry build
      - uses: actions/upload-artifact@v3
        with:
          name: python-artifact
          path: dist/*
      - name: Publish to test.pypi.org
        id: pypi-test-publish
        if: |
          github.ref == 'refs/heads/develop' ||
          startsWith(github.ref, 'refs/heads/release')
        env:
          POETRY_PYPI_TOKEN_TESTPYPI: ${{secrets.POETRY_PYPI_TOKEN_TESTPYPI}}
        run: |
          poetry config repositories.testpypi https://test.pypi.org/legacy/
          poetry publish -r testpypi
          echo "PACKAGE=$(poetry version | awk '{print $1}')" >> $GITHUB_ENV
      - name: Publish to pypi.org
        id: pypi-publish
        if: ${{ github.ref == 'refs/heads/main' }}
        env:
          POETRY_PYPI_TOKEN_PYPI: ${{secrets.POETRY_PYPI_TOKEN_PYPI}}
        run: |
          poetry publish
      - name: Log in to the Container registry
        if: |
          steps.pypi-test-publish.conclusion == 'success' ||
          steps.pypi-publish.conclusion == 'success'
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        if: |
          steps.pypi-test-publish.conclusion == 'success' ||
          steps.pypi-publish.conclusion == 'success'
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=semver,pattern={{version}},value=${{ env.software_version }}
            type=raw,value=${{ env.venue }}
      - name: Wait for package
        if: |
          steps.pypi-test-publish.conclusion == 'success' ||
          steps.pypi-publish.conclusion == 'success'
        run: |
          pip install tenacity
          ${GITHUB_WORKSPACE}/.github/workflows/wait-for-pypi.py ${{env.pyproject_name}}==${{ env.software_version }}
      - name: Build and push Docker image
        if: |
          steps.pypi-test-publish.conclusion == 'success' ||
          steps.pypi-publish.conclusion == 'success'
        uses: docker/build-push-action@v3
        with:
          context: .
          file: docker/Dockerfile
          build-args: |
            SOURCE=${{env.pyproject_name}}==${{ env.software_version }}
          push: true
          pull: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      ## Set environment variables
      - name: Configure Initial YAML file and environment variables
        run: |
          echo "THE_VERSION=${{ env.project_version }}" >> $GITHUB_ENV;
          echo "GIT_BRANCH=${GITHUB_REF#refs/heads/}" >> $GITHUB_ENV;
          GITHUB_REF_READABLE="${GITHUB_REF//\//-}"
          echo "GITHUB_REF_READABLE=${GITHUB_REF_READABLE}" >> $GITHUB_ENV
          echo "TARGET_ENV_UPPERCASE=SIT" >> $GITHUB_ENV

      - name: Setup local DynamoDB
        run: docker run -d -p 8000:8000 amazon/dynamodb-local

      - name: Load sample
        run: python3 tests/example_load_data.py

      - name: Test with pytest
        run: pytest tests/test_api.py

      
      # Setup Terraform to Deploy

      - name: Configure AWS Credentials as Environment Variables
        run: echo "AWS_ACCESS_KEY_ID=${{ secrets[format('AWS_ACCESS_KEY_ID_SERVICES_{0}', env.TARGET_ENV_UPPERCASE)] }}" >> $GITHUB_ENV |
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets[format('AWS_SECRET_ACCESS_KEY_SERVICES_{0}', env.TARGET_ENV_UPPERCASE)] }}" >> $GITHUB_ENV

      - name: Validate AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: us-west-2
          role-session-name: GitHubActions
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets[format('AWS_ACCESS_KEY_ID_SERVICES_{0}', env.TARGET_ENV_UPPERCASE)] }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_SERVICES_{0}', env.TARGET_ENV_UPPERCASE)] }}
      - run: aws sts get-caller-identity

      #- name: upload image to ECR
      #  uses: appleboy/docker-ecr-action@master
      #  with:
      #    access_key: ${{ secrets[format('AWS_ACCESS_KEY_ID_SERVICES_{0}', env.TARGET_ENV_UPPERCASE)] }}
      #    secret_key: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_SERVICES_{0}', env.TARGET_ENV_UPPERCASE)] }}
      #    registry: ${{ env.REGISTRY }}
      #    repo: hydrocron-api
      #    region: us-west-2
      #    auto_tag: true
      #    daemon_off: false
      #    dockerfile: docker/Dockerfile
      #    context: example

      #- name: Build and deploy docker to ECR
      #  run: |
      #    aws configure get ngap-service-sit.${{ secrets[format('AWS_ACCESS_KEY_ID_SERVICES_{0}', env.TARGET_ENV_UPPERCASE)] }}
      #    aws configure get ngap-service-sit.${{ secrets[format('AWS_SECRET_ACCESS_KEY_SERVICES_{0}', env.TARGET_ENV_UPPERCASE)] }}
      #    bash ./docker/build-docker.sh -n podaac-hydrocron -v ${{ env.THE_VERSION }}
      #    bash ./docker/push-docker-ecr.sh --aws-account ${{ secrets[format('AWS_ACCESS_KEY_ID_SERVICES_{0}', env.TARGET_ENV_UPPERCASE)] }} --docker-tag ${{ env.DOCKER_METADATA_OUTPUT_TAGS }} --tf-venue "SIT"


      - uses: hashicorp/setup-terraform@v2.0.3
        with:
          terraform_version: 1.0.3

      - name: Deploy Terraform
        #if: |
        #  github.ref == 'refs/heads/develop' ||
        #  github.ref == 'refs/heads/main'    ||
        #  startsWith(github.ref, 'refs/heads/release') ||
        #  github.event.head_commit.message == '/deploy sit' ||
        #  github.event.head_commit.message == '/deploy uat'
        working-directory: terraform/
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets[format('AWS_ACCESS_KEY_ID_SERVICES_{0}', env.TARGET_ENV_UPPERCASE)] }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_SERVICES_{0}', env.TARGET_ENV_UPPERCASE)] }}
          AWS_DEFAULT_REGION: us-west-2
          
          TF_VAR_hydrocronapi_api_docker_image: "podaac/podaac-cloud/podaac-hydrocron:${{ env.THE_VERSION }}"

        run: |
          source bin/config.sh ${{ env.THE_ENV }}
          terraform plan -var-file=tfvars/"${{ env.THE_ENV }}".tfvars -var="app_version=${{ env.THE_VERSION }}" -out="tfplan"
          terraform apply -auto-approve tfplan
